# 250214 upload

import streamlit as st
from PIL import Image
from io import BytesIO
from PIL import Image
import base64
import os
import json
from openai import OpenAI
import pandas as pd
from io import StringIO
import pdfplumber
import openai
from openai import OpenAI
from langchain_community.document_loaders import PyMuPDFLoader
import base64
import fitz
import time
from datetime import datetime, timedelta

os.environ["OPENAI_API_KEY"] = "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"
st.set_page_config(layout="wide", page_title="Voronoi Label Studio🧑‍💻")

st.write("## Clinical dataset LabelMate")
st.markdown("Please upload your files (the **full paper** and **table images**) first, and review the table generated by GPT. There may be **errors**, so please check carefully.")
st.sidebar.write("## Upload Your Files :gear:")

tab1, tab2 = st.tabs(["Efficacy", "Toxicity"])
paper_pdf_upload = st.sidebar.file_uploader("Full Paper PDF format", type=["PDF"]) # 1개까지 허용
paper_efficacy_upload = st.sidebar.file_uploader("Efficacy Table PNG format", type=["PNG"], accept_multiple_files=True) # 3개까지 허용
paper_toxicity_upload = st.sidebar.file_uploader("Toxicity Table PNG format", type=["PNG"], accept_multiple_files=True) # 3개까지 허용
paper_dose_upload = st.sidebar.file_uploader("Dose info Table PNG format", type=["PNG"], accept_multiple_files=True) # 3개까지 허용

def check_column_headers(df1, df2):
    return list(df1.columns) == list(df2.columns)

def encode_image(image_bytes):
    return base64.b64encode(image_bytes).decode('utf-8')

def eff_pdf_to_text(upload):

    if upload is not None:
            start = time.time()
            file_bytes = upload.read()
            pdf_document = fitz.open(stream=file_bytes, filetype="pdf")
            full_text = ""
            for page_num in range(pdf_document.page_count):
                page = pdf_document.load_page(page_num)
                full_text += page.get_text()

            client = OpenAI()
            response_text = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "text",
                                "text": f"제공한 텍스트 자료에서 Abstract 문단 내용과 efficacy에 대해 설명하고 있는 모든 문단들을 가져와서 출력해줘. 텍스트 자료:{full_text}.",
                            },
                        ],
                    }
                ],
            )
            end = time.time()
            elapsed_time = end - start
            print(f"eff_pdf_to_text()에 걸린 시간: {elapsed_time} sec")

            related_text_input = response_text.choices[0].message.content
            print("최종 사용할 논문 본문 내용:\n", related_text_input)
            return related_text_input

def efficacy_table_image(upload):

    if upload:
        start = time.time()
        base64_image = encode_image(upload.read())
        client = OpenAI()
        response_replic = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": """

                            **해야하는 일 **
                            제공된 이미지에 있는 표를 텍스트 표로 바꿔서 csv format으로 반환해줘. 추가 설명은 주지 말고 CSV 포멧 표만 반환해.
                            이때, 표에 함께 있는 caption 글을 csv format 맨 밑에 행에 함께 반환해줘. 행 누락 없이 모든 정보가 담겨야해. "정보 누락하지마"

                            **고려할 것**
                            행/열을 잘 구분하고, 이때 **띄어쓰기나 볼드체 등의 특징**을 보고, **상위 개념 하위 개념** 관계를 모두 파악하여 상위항목(예를 들어 Objective response rate)-하위항목(at 8 mo)으로 **합쳐서 행**으로 만들어줘.
                            수치가 **정확**하게 기입되어야해. 모르겠으면 빈칸으로 남겨두고, 확실한 것만 기입해. 가끔 윗 행과 아래 행의 수치를 바꿔서 적거나 새로 만드는 경우가 있더라. 헷갈리면 빈칸으로 냅둬.

                            """,
                        },
                        {
                            "type": "image_url",
                            "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"},
                        },
                    ],
                }
            ],
        )

        response_replic = response_replic.choices[0].message.content

        rows111 = response_replic.split("\n")
        data111 = [row.split(",") for row in rows111]
        df111 = pd.DataFrame(data111)
        df111 = df111.applymap(lambda x: x.replace('"', '') if isinstance(x, str) else x)

        end = time.time()
        elapsed_time = end - start
        print(f"efficacy_table_image()에 걸린 시간: {elapsed_time} sec \n\n")

        related_table_input = df111.to_csv(index=False)

        rows111 = related_table_input.split("\n")
        data111 = [row.split(",") for row in rows111]
        df111 = pd.DataFrame(data111)
        df = df111.applymap(lambda x: x.replace('"', '') if isinstance(x, str) else x)

        start_index = df[df.iloc[:, 0].str.contains('```', na=False)].index[0]
        end_index = df.iloc[start_index+1:][df.iloc[start_index+1:, 0].str.contains('```', na=False)].index[0]
        related_table_input = df.iloc[start_index+2:end_index]
        
        print("\n efficacy_table_image() 표 복제 출력:",related_table_input)
    else:
            related_table_input = None
    return related_table_input

def efficacy_table(related_table_input, related_text_input):

    start = time.time()
    client = OpenAI()
    response_our_excel = client.chat.completions.create(
    model="gpt-4o",
    messages=[
        {
            "role": "user",
            "content": f"""
            You have received both a table image and its corresponding CSV input. 
            Please verify if the CSV input correctly matches the table image. 
            If discrepancies are found, correct them and update the CSV input to reflect the accurate table. 
            Use the corrected CSV to construct a new dataframe as per the output data structure instructions below.

            ### **Input Data Rules:**
            - The input is:
            ```
              {related_table_input}
            ```
            - **Do NOT modify, rephrase, summarize, omit, or alter any text, numbers, units, expressions, or symbols in any way.**
            - **Preserve full content, even if the text is long or contains commas, parentheses, or special characters.**
            - **Extract data exactly as it appears in the original table, maintaining full text integrity.**
            - Extract the correct values **by matching the row and column structure**, ensuring all relevant cell content is retained.

            ### **Output Data Structure:**
            The output should be a new table with the following columns:
            ["treat_group", "sub_group", "no. patients", "category", "value(#)", "value(%)", "range_type", "range_low", "range_high"]
            Each column follows these strict rules:
            - **treat_group**: If data is divided by dosage units, extract only the dosage value here.
            - **sub_group**: Extracted from the column headers of the input table. If there’s dosage info, exclude it.
            - **no. patients**: Extract the total number of patients for each `sub_group`. Only the numeric value should be written (e.g., if total patients = 10, just write 10, not `N=10`).
            - **category**: Extracted from the row headers. This should include the full row header text exactly as written (e.g., `"Progression-free survival†, Median (95% CI) — mo"`, with all symbols and formatting). **Do not truncate or shorten this text.**
            - If a value represents a count (#) or percentage (%), categorize it as `value(#)` or `value(%)` accordingly. Ensure metrics like "mo" go into the `value(#)` column, and correctly identify percentages.
            - **Do NOT alter or remove units**. If a cell contains multiple values, keep them together as a single string.
            - **range_type**: Extract the confidence interval or range exactly as stated (e.g., `"95% CI"`).
            - **range_low** / **range_high**: Extract the exact minimum and maximum values from the range **without modification**.

            ### **Strict Output Rules:**
            - **Preserve all formatting, symbols, parentheses, spacing, commas, and special characters exactly as they appear in the input.**
            - **If a value includes a comma but was in a single cell in the original table, keep it together. Do not split it into multiple columns.**
            - Ensure **category** contains the full original row header text **without omission**. Do not truncate long text.
            - **Sometimes, data may be missing in output**. Ensure all data is included, check for any missing rows or entries.
            - Return the final structured data in pure CSV format, without additional text, explanations, or notes.
            """
        }
    ]
)


    print(response_our_excel)
    response_our_excel_data = response_our_excel.choices[0].message.content

    rows111 = response_our_excel_data.split("\n")
    data111 = [row.split(",") for row in rows111]
    df111 = pd.DataFrame(data111)
    df111 = df111.applymap(lambda x: x.replace('"', '') if isinstance(x, str) else x)

    header_idx = df111[df111[0] == 'treat_group'].index[0]
    df111.columns = df111.iloc[header_idx].values
    df_cleaned = df111.iloc[header_idx + 1:].reset_index(drop=True)
    end_idx = df_cleaned[df_cleaned.iloc[:, 0].str.contains('```', na=False)].index[0]
    efficacy_output = df_cleaned.iloc[:end_idx].reset_index(drop=True)

    end = time.time()
    elapsed_time = end - start
    print(f"efficacy_table()에 걸린 시간: {elapsed_time} sec\n\n")

    efficacy_output = efficacy_output.sort_values(by=['treat_group', 'sub_group'], ascending=[True, True]).reset_index(drop=True)
    return efficacy_output

def efficacy_add_table(eff_table1, eff_table2):
    if eff_table1 is not None and eff_table2 is not None: 
        if check_column_headers(eff_table1, eff_table2):
            efficacy_output = pd.concat([eff_table1, eff_table2], axis=0, ignore_index=True)
            return efficacy_output

    elif eff_table1 is not None and eff_table2 is None: 
            efficacy_output = eff_table1
            return efficacy_output

    else:
        efficacy_output = None
        return None


## display setting... 
if paper_pdf_upload is None:
    st.markdown("논문 PDF 파일을 업로드해주세요.")

else:

    folder_name = paper_pdf_upload.name.split('.')[0]
    if not os.path.exists(folder_name):
        os.makedirs(folder_name)

    diaplay_replica_efficacy_excel_name = f"./{folder_name}/replica_efficacy_excel.xlsx"  
    diaplay_replica_efficacy_excel_name2 = f"./{folder_name}/replica_efficacy_excel2.xlsx"    
    diaplay_efficacy_excel_name = f"./{folder_name}/efficacy_excel.xlsx"
    diaplay_toxicity_excel_name = f"./{folder_name}/toxicity_excel.xlsx"

    with tab1:

        run_button, replica_button = tab1.columns([1,2])

        status_placeholder_left = st.empty()

        if run_button:
            st.session_state.clear()
            status_placeholder_left.markdown("Running Efficacy...")

            if paper_pdf_upload is None and len(paper_efficacy_upload) == 0:
                status_placeholder_left.markdown("Please upload your files!")

            else:
                status_placeholder_left.markdown("Reading the paper...")
                if paper_pdf_upload is not None:  
                    related_text_input = eff_pdf_to_text(upload=paper_pdf_upload)
                else:
                    related_text_input = None

                if len(paper_efficacy_upload) >= 2:
                    status_placeholder_left.markdown("Recognizing the table in the image...Efficacy Table 2개일 때")
                    related_table_input1 = efficacy_table_image(upload=paper_efficacy_upload[0])
                    related_table_input2 = efficacy_table_image(upload=paper_efficacy_upload[1])
                    related_table_input1.to_excel(diaplay_replica_efficacy_excel_name, index=False, engine='openpyxl')
                    related_table_input2.to_excel(diaplay_replica_efficacy_excel_name2, index=False, engine='openpyxl')

                    status_placeholder_left.markdown("Organizing the table...")
                    efficacy_table_output1 = efficacy_table(related_table_input1, related_text_input)
                    efficacy_table_output2 = efficacy_table(related_table_input2, related_text_input)
                    efficacy_table_output = efficacy_add_table(efficacy_table_output1, efficacy_table_output2)
                    efficacy_table_output.to_excel(diaplay_efficacy_excel_name, index=False, engine='openpyxl')
                    
                    status_placeholder_left.markdown(f"DataFrame successfully saved to '{diaplay_efficacy_excel_name}'")
                    status_placeholder_left.empty()

                elif len(paper_efficacy_upload) == 1:
                    status_placeholder_left.markdown("Recognizing the table in the image...Efficacy Table 1개일 때")
                    related_table_input = efficacy_table_image(upload=paper_efficacy_upload[0])
                    related_table_input.to_excel(diaplay_replica_efficacy_excel_name, index=False, engine='openpyxl')

                    # status_placeholder_left.markdown("Organizing the table...")
                    # efficacy_table_output = efficacy_table(paper_pdf_upload, related_table_input, related_text_input)
                    # efficacy_table_output.to_excel(diaplay_efficacy_excel_name, index=False, engine='openpyxl')

                    # status_placeholder_left.markdown(f"DataFrame successfully saved to '{diaplay_efficacy_excel_name}'")
                    status_placeholder_left.empty()

                else:
                    status_placeholder_left.markdown("Efficacy Table 이미지가 업로드되지 않았습니다. 우측의 출력 테이블은 오직 논문의 본문 내용에만 의존하여 생성됩니다.")
                    status_placeholder_left.markdown("Organizing the table...")
                    efficacy_table_output = efficacy_table(None, related_text_input)
                    efficacy_table_output.to_excel(diaplay_efficacy_excel_name, index=False, engine='openpyxl')
                    status_placeholder_left.markdown(f"DataFrame successfully saved to '{diaplay_efficacy_excel_name}'")
                    status_placeholder_left.empty()

        
        ### Real display ...
        if 'eff_image_index' not in st.session_state:
            st.session_state.eff_image_index = 0

        if os.path.exists(diaplay_efficacy_excel_name):
            left, right = tab1.columns([1, 1])

            if len(paper_efficacy_upload) >= 2:
                current_image_file = paper_efficacy_upload[st.session_state.eff_image_index]
                current_image = Image.open(current_image_file)

                left.write("Original Table :camera:")
                left.image(current_image, caption=f"Image {st.session_state.eff_image_index + 1} of {len(paper_efficacy_upload)}")

            elif len(paper_efficacy_upload) == 1:
                current_image_file = paper_efficacy_upload[st.session_state.eff_image_index]
                current_image = Image.open(current_image_file)
                left.write("Original Table :camera:")
                left.image(current_image)

            saved_df = pd.read_excel(diaplay_replica_efficacy_excel_name, sheet_name=None)  # 모든 시트 읽기
            sheet_name = list(saved_df.keys())[0]  # 첫 번째 시트 이름
            saved_df[sheet_name].reset_index(inplace=True)
            right.write("Suggested Excel File :wrench:")
            edited_df = right.data_editor(saved_df[sheet_name], use_container_width=True, height=1000, num_rows = "dynamic")

            if replica_button:
                edited_df.to_excel(diaplay_replica_efficacy_excel_name, index=False, engine='openpyxl')
                status_placeholder_left.markdown(f"복제된 표는 '{diaplay_replica_efficacy_excel_name}'에 저장되었습니다. 최종 output을 계산하고 있습니다...")

                status_placeholder_left.markdown("Organizing the table...")
                efficacy_table_output = efficacy_table(paper_pdf_upload, edited_df, related_text_input)
                efficacy_table_output.to_excel(diaplay_efficacy_excel_name, index=False, engine='openpyxl')

                status_placeholder_left.markdown(f"최종 output은 '{diaplay_efficacy_excel_name}'에 저장되었습니다.")
                status_placeholder_left.empty()

                saved_df = pd.read_excel(diaplay_efficacy_excel_name, sheet_name=None)  # 모든 시트 읽기
                sheet_name = list(saved_df.keys())[0]  # 첫 번째 시트 이름
                saved_df[sheet_name].reset_index(inplace=True)
                right.write("Suggested Excel File :wrench:")
                edited_df = right.data_editor(saved_df[sheet_name], use_container_width=True, height=1000, num_rows = "dynamic")

                unique_treat_group = saved_df[sheet_name]['treat_group'].nunique()
                unique_sub_group = saved_df[sheet_name]['sub_group'].nunique()                                 
                unique_treat_group_values = saved_df[sheet_name]['treat_group'].unique()
                unique_sub_group_values = saved_df[sheet_name]['sub_group'].unique()
                effi_total_rows = len(saved_df[sheet_name])

                right.write("Suggested Excel File :wrench:")
                edited_df = right.data_editor(saved_df[sheet_name], use_container_width=True, height=1000, num_rows = "dynamic")
                st.info(f"""
                    📢 **생성된 엑셀 표의 값 요약**입니다. 원본 테이블과 비교하며 확인해 주세요!  

                    | 항목               | 고유 값 개수   | 고유 값들                                  |
                    |------------------|-------------|----------------------------------------|
                    | **Treat group**   | {unique_treat_group}개  | {', '.join(map(str, unique_treat_group_values))}  |
                    | **Sub group**     | {unique_sub_group}개  | {', '.join(map(str, unique_sub_group_values))}  |

                    📊 **총 행의 개수**는 **{effi_total_rows}개**입니다.  

                    ---

                    ➡️ **문제가 있다면 다시 RUN 시켜주세요.**  
                    """
                )